<html> 
<head> 
<title></title> 
<style>
body { margin: 0px; padding: 0px; }
canvas { width: 100%; height: 100% }
</style> 
<script src="js/three.min.js"></script> 
<script src="js/OrbitControls.js"></script> 
<script src="js/Detector.js"></script> 
<script src="js/CollisionUtils.js"></script>
<script src="js/Collisions.js"></script>
<script src="js/libs/stats.min.js"></script>
<script>
function Game() {
	this.speed = 5;
	this.limit_x = 280;
	this.limit_z = 200;
	this.width = window.innerWidth;
	this.height = window.innerHeight;
	this.scene = new THREE.Scene();
	this.camera = new THREE.PerspectiveCamera(30, this.width / this.height, 0.1, 20000);
	this.renderer;
	this.controls;
	this.stats;
	this.key = [];
	this.spheres = [];

	this.init = function() {
		// render
		if ( Detector.webgl ){
			this.renderer = new THREE.WebGLRenderer( {antialias:true} )
		}else{
			this.renderer = new THREE.CanvasRenderer(); 
		}
		this.renderer.setSize(this.width, this.height);
		container.appendChild(this.renderer.domElement);

		// camera
		this.camera.position.set(0,550,550);
		this.scene.add(this.camera);
		this.camera.lookAt(this.scene.position);

		// controls
		this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
		this.controls.noKeys = true;

		// light
		var ambientLight = new THREE.AmbientLight(0x222222);
		this.scene.add(ambientLight);
		var directionalLight = new THREE.DirectionalLight(0xffffff);
		directionalLight.position.set(1, 1, 1).normalize();
		this.scene.add(directionalLight);

		// floor
		var floorMaterial = new THREE.MeshBasicMaterial( { color: 0x444444, side: THREE.DoubleSide } );
		var floorGeometry = new THREE.PlaneGeometry(this.limit_x*2, this.limit_z*2, 1, 1);
		var floor = new THREE.Mesh(floorGeometry, floorMaterial);
		floor.position.y = -8;
		floor.rotation.x = Math.PI / 2;
		this.scene.add(floor);

		// sky
		var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
		var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xaaccff, side: THREE.BackSide } );
		var skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
		this.scene.add(skyBox);

		// cubes
		var cposition = new THREE.Vector3(230, 3, 0);
		var geometry = new THREE.CubeGeometry(10,20,cube_width_z);
		var material = new THREE.MeshLambertMaterial({color: 0x000088, opacity: 0.5}); 
		cube = new THREE.Mesh(geometry, material); 
		cube.position = cposition;
		this.scene.add(cube);
		THREE.Collisions.colliders.push(THREE.CollisionUtils.MeshOBB(cube));
	
		var cposition = new THREE.Vector3(-230, 3, 0);
		var geometry = new THREE.CubeGeometry(10,20,cube_width_z);
		var material = new THREE.MeshLambertMaterial({color: 0x000088, opacity: 0.5}); 
		cube2 = new THREE.Mesh(geometry, material); 
		cube2.position = cposition;
		this.scene.add(cube2);
		THREE.Collisions.colliders.push(THREE.CollisionUtils.MeshOBB(cube2));
	
		// sphere
		this.addSphere();

		// stats - fps
		this.stats = new Stats();
		this.stats.domElement.style.position = 'absolute';
		this.stats.domElement.style.top = '0px';
		container.appendChild(this.stats.domElement);

		// events
		(function(obj){
			document.body.onkeydown = document.body.onkeyup = function(e){
				var e = e || event;
				obj.key[e.keyCode] = e.type == 'keydown';
			};
		})(this);
		(function(obj){
			obj.renderer.domElement.addEventListener('mouseup', function(event){
				obj.addSphere();
			});
		})(this);

		this.animate();
	};

	this.addSphere = function() {
		var rad = 7;
		var sposition = new THREE.Vector3(0, 0, 0);
		var geometry = new THREE.SphereGeometry(rad, 30, 30);
		var material = new THREE.MeshLambertMaterial({color: 0x000088}); 
		var sphere = new THREE.Mesh(geometry, material); 
		sphere.position = sposition;
		this.scene.add(sphere);
		var sc = new THREE.SphereCollider(sposition, rad);
		sc.mesh = sphere;
		THREE.Collisions.colliders.push(sc);
		var len = this.spheres.push(sphere);
		direction_x[len-1] = Math.round(Math.random());
		direction_z[len-1] = Math.round(Math.random());
	};

	this.animate = function() {
		(function(obj){
			requestAnimationFrame(function(){
				obj.animate();
			});
		})(this);
		this.update();
		this.controls.update();
		this.stats.update();
		this.renderer.render(this.scene, this.camera);
	};

	this.update = function() {
		// events keys
		//console.log("up="+this.key[38]+"; down="+this.key[40]+"; wup="+this.key[87]+"; sdown="+this.key[83]+";");
		if(this.key[38]){ //cima
			if(cube.position.z-(cube_width_z/2) > -this.limit_z){
				cube.position.z -= speed_cube;
			}
		}else if(this.key[40]){ //baixo
			if(cube.position.z+(cube_width_z/2) < this.limit_z){
				cube.position.z += speed_cube;
			}
		}
		if(this.key[33]){ //page up
			cube.rotation.y += .1;
		}
		if(this.key[34]){ //page down
			cube.rotation.y -= .1;
		}
		if(this.key[87]){ //w cima
			if(cube2.position.z-(cube_width_z/2) > -this.limit_z){
				cube2.position.z -= speed_cube;
			}
		}else if(this.key[83]){ //s baixo
			if(cube2.position.z+(cube_width_z/2) < this.limit_z){
				cube2.position.z += speed_cube;
			}
		}
	
		// sphere move
		var i;
		for(i in this.spheres){
			if(direction_x[i] == 1){
				this.spheres[i].position.x += this.speed;
			}else if(direction_x[i] != 1){
				this.spheres[i].position.x -= this.speed;
			}
			if(direction_z[i] == 1){
				this.spheres[i].position.z += this.speed;
			}else if(direction_z[i] != 1){
				this.spheres[i].position.z -= this.speed;
			}

			if(this.spheres[i].position.x >= this.limit_x || this.spheres[i].position.x <= -this.limit_x){
				direction_x[i] = direction_x[i] != 1?1:0;
				//delete this.spheres[i];
				//delete direction_x[i];
				//delete direction_z[i];
			}
			if(this.spheres[i].position.z >= this.limit_z || this.spheres[i].position.z <= -this.limit_z){
				direction_z[i] = direction_z[i] != 1?1:0;
			}

			// colisao
			var ray = new THREE.Ray( this.spheres[i].position, new THREE.Vector3( 0, 0, 1 ) );
			var c = THREE.Collisions.rayCastNearest( ray );

			var color = "0x"+((1<<24)*Math.random()|0).toString(16);
			if(c != null && c.distance == -1){
				direction_x[i] = direction_x[i] != 1?1:0;
				c.mesh.material.color.setHex(color);
			}
		}

		/*var vector = new THREE.Vector3( 0, 0, 0 );
		var ray = new THREE.Ray( cube.position, vector.sub( cube.position ).normalize() );
		var cs = THREE.Collisions.rayCastAll( ray );
		//console.log(cs);
		if ( cs.length > 0 ) {
			console.log(cs.length + " colisao ");
			for ( var i = 0; i < cs.length; i ++ ) {
				console.log(cs[i].mesh);
				//console.log(cs[i].mesh.id);
				cs[ i ].mesh.material.color.setHex( 0xff0000 );
			}
		} else {
			console.log("sem colisao");
		}*/

	}
}


var cube_width_z = 100;
var speed_cube = 5;
var cube, cube2;
var direction_x = []; //0 left, 1 right
var direction_z = []; //0 top, 1 down

function Player() {
	this.cube;
	this.cubeWidth = 100;
	this.points = 0;


	this.makeCube = function() {

	}

}

window.onload = function(){
	var container = document.getElementById('container');
	var g = new Game();
	g.init();
}

/*
	var geometry = new THREE.SphereGeometry(1.2, 50, 50); 
	var material = new THREE.MeshLambertMaterial({color: 0x008800}); 
	sphere = new THREE.Mesh(geometry, material); 
	sphere.position.x = -10;
	this.scene.add(sphere);

	var material = new THREE.LineBasicMaterial({color: 0xffffff, linewidth:2}); 
	var geometry = new THREE.Geometry();
	geometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) ); 
	geometry.vertices.push( new THREE.Vector3( 1, 0, 0 ) ); 
	//geometry.vertices.push( new THREE.Vector3( 1, 0, -1 ) );

//	var line = new THREE.Line( geometry, material );
//	line.position.z = -1;
//	this.scene.add(line); 
*/

</script> 
</head> 
<body>
<div id="container"></div>
</body> 
</html>
