<html> 
<head> 
<title></title> 
<style>
body { margin: 0px; padding: 0px; }
canvas { width: 100%; height: 100% }
</style> 
<script src="js/three.min.js"></script> 
<script src="js/OrbitControls.js"></script> 
<script src="js/Detector.js"></script> 
<script src="js/CollisionUtils.js"></script>
<script src="js/Collisions.js"></script>
<script src="js/libs/stats.min.js"></script>
<script>
var scene, camera, renderer, container;
var cube, cube2, sphere;
var controls;
var stats;
var direction_x = 0; //0 left, 1 right
var direction_z = 0; //0 top, 1 down
var limit_x = 280;
var limit_z = 200;
var speed = 5, speed_bar = 4;

function init(){
	// scene
	scene = new THREE.Scene();

	// render
	var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
	container = document.getElementById('container');
	if ( Detector.webgl ){
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	}else{
		renderer = new THREE.CanvasRenderer(); 
	}
	renderer.setSize(WIDTH, HEIGHT);
	container.appendChild(renderer.domElement);

	// camera
	camera = new THREE.PerspectiveCamera(30, WIDTH / HEIGHT, 0.1, 20000);
	camera.position.set(0,550,550);
	scene.add(camera);
	camera.lookAt(scene.position);

	// controls
	controls = new THREE.OrbitControls(camera, renderer.domElement);
	controls.noKeys = true;

	// light
	var ambientLight = new THREE.AmbientLight(0x222222);
	scene.add(ambientLight);
	var directionalLight = new THREE.DirectionalLight(0xffffff);
	directionalLight.position.set(1, 1, 1).normalize();
	scene.add(directionalLight);

	// floor
	var floorMaterial = new THREE.MeshBasicMaterial( { color: 0x444444, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneGeometry(limit_x*2, limit_z*2, 1, 1);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -7;
	floor.rotation.x = Math.PI / 2;
	scene.add(floor);

	// sky
	var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xaaccff, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
	scene.add(skyBox);

	// cube
	var cposition = new THREE.Vector3(230, 4, 0);
	var geometry = new THREE.CubeGeometry(10,20,100);
	var material = new THREE.MeshLambertMaterial({color: 0x000088, opacity: 0.5}); 
	cube = new THREE.Mesh(geometry, material); 
	cube.position = cposition;
	scene.add(cube);
	THREE.Collisions.colliders.push(THREE.CollisionUtils.MeshOBB(cube));
	
	var cposition = new THREE.Vector3(-230, 4, 0);
	var geometry = new THREE.CubeGeometry(10,20,100);
	var material = new THREE.MeshLambertMaterial({color: 0x000088, opacity: 0.5}); 
	cube2 = new THREE.Mesh(geometry, material); 
	cube2.position = cposition;
	scene.add(cube2);
	THREE.Collisions.colliders.push(THREE.CollisionUtils.MeshOBB(cube2));
	
	// sphere
	var rad = 7;
	var sposition = new THREE.Vector3(0, 0, 0);
	var geometry = new THREE.SphereGeometry(rad, 30, 30);
	var material = new THREE.MeshLambertMaterial({color: 0x000088}); 
	sphere = new THREE.Mesh(geometry, material); 
	sphere.position = sposition;
	scene.add(sphere);
	var sc = new THREE.SphereCollider(sposition, rad);
	sc.mesh = sphere;
	THREE.Collisions.colliders.push(sc);

	// stats - fps
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	container.appendChild(stats.domElement);

	// events
	document.addEventListener("keydown", function(event){
		//console.log(event.keyCode);
		if(event.keyCode == '37'){ //esquerda
			//cube.position.x -= 1;
		}else if(event.keyCode == '38'){ //cima
			cube.position.z -= speed_bar;
		}else if(event.keyCode == '39'){ //direita
			//cube.position.x += 1;
		}else if(event.keyCode == '40'){ //baixo
			cube.position.z += speed_bar;
		}else if(event.keyCode == '33'){ //page up
			cube.rotation.y += .1;
		}else if(event.keyCode == '34'){ //page down
			cube.rotation.y -= .1;
		}else if(event.keyCode == '87'){ //w cima
			cube2.position.z -= speed_bar;
		}else if(event.keyCode == '83'){ //s baixo
			cube2.position.z += speed_bar;
		}

	}, false);
	renderer.domElement.addEventListener('mousemove', function(event){

	});
	renderer.domElement.addEventListener('mousedown', function(event){
		//rotation();
		//update();
	});
	renderer.domElement.addEventListener('mouseup', function(event){

	});

}

function animate() {
	requestAnimationFrame(animate);
	update();
	controls.update();
	stats.update();
	renderer.render(scene, camera);
}

function update(){
	if(direction_x == 1){
		sphere.position.x += speed;
	}else if(direction_x == 0){
		sphere.position.x -= speed;
	}
	if(direction_z == 1){
		sphere.position.z += speed;
	}else if(direction_z == 0){
		sphere.position.z -= speed;
	}

	if(sphere.position.x >= limit_x || sphere.position.x <= -limit_x){
		direction_x = direction_x == 0?1:0;
	}
	if(sphere.position.z >= limit_z || sphere.position.z <= -limit_z){
		direction_z = direction_z == 0?1:0;
	}

	var ray = new THREE.Ray( sphere.position, new THREE.Vector3( 0, 0, 1 ) );
	var c = THREE.Collisions.rayCastNearest( ray );

	var color = "0x"+((1<<24)*Math.random()|0).toString(16);
	if(c != null && c.distance == -1){
		direction_x = direction_x == 0?1:0;
		c.mesh.material.color.setHex(color);
	}

	/*var vector = new THREE.Vector3( 0, 0, 0 );
	var ray = new THREE.Ray( cube.position, vector.sub( cube.position ).normalize() );
	var cs = THREE.Collisions.rayCastAll( ray );
	//console.log(cs);
	if ( cs.length > 0 ) {
		console.log(cs.length + " colisao ");
		for ( var i = 0; i < cs.length; i ++ ) {
			console.log(cs[i].mesh);
			//console.log(cs[i].mesh.id);
			cs[ i ].mesh.material.color.setHex( 0xff0000 );
		}
	} else {
		console.log("sem colisao");
	}*/

}

function rotation(){
	cube.rotation.y += .05;

	renderer.render(scene, camera);
	requestAnimationFrame(rotation);
	stats.update();
}

window.onload = function(){
	init();
	animate();
}

/*
	var geometry = new THREE.SphereGeometry(1.2, 50, 50); 
	var material = new THREE.MeshLambertMaterial({color: 0x008800}); 
	sphere = new THREE.Mesh(geometry, material); 
	sphere.position.x = -10;
	scene.add(sphere);

	var material = new THREE.LineBasicMaterial({color: 0xffffff, linewidth:2}); 
	var geometry = new THREE.Geometry();
	geometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) ); 
	geometry.vertices.push( new THREE.Vector3( 1, 0, 0 ) ); 
	//geometry.vertices.push( new THREE.Vector3( 1, 0, -1 ) );

//	var line = new THREE.Line( geometry, material );
//	line.position.z = -1;
//	scene.add(line); 
*/

</script> 
</head> 
<body>
<div id="container"></div>
</body> 
</html>
