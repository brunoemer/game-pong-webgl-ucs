<html> 
<head> 
<title></title> 
<style>
body { margin: 0px; padding: 0px; }
canvas { width: 100%; height: 100% }
</style> 
<script src="js/three.min.js"></script> 
<script src="js/OrbitControls.js"></script> 
<script src="js/Detector.js"></script> 
<script src="js/CollisionUtils.js"></script>
<script src="js/Collisions.js"></script>
<script src="js/libs/stats.min.js"></script>
<script>
var scene, camera, renderer, container;
var cube, sphere;
var controls;
var stats;
var direction = 1; //0 right, 1 left, 2 top, 3 down

function init(){
	// scene
	scene = new THREE.Scene();

	// render
	var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
	container = document.getElementById('container');
	if ( Detector.webgl ){
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	}else{
		renderer = new THREE.CanvasRenderer(); 
	}
	renderer.setSize(WIDTH, HEIGHT);
	container.appendChild(renderer.domElement);

	// camera
	camera = new THREE.PerspectiveCamera(50, WIDTH / HEIGHT, 0.1, 20000);
	camera.position.set(0,30,10);
	scene.add(camera);
	camera.lookAt(scene.position);

	// controls
	controls = new THREE.OrbitControls(camera, renderer.domElement);
	controls.noKeys = true;

	// light
	var ambientLight = new THREE.AmbientLight(0x222222);
	scene.add(ambientLight);
	var directionalLight = new THREE.DirectionalLight(0xffffff);
	directionalLight.position.set(1, 1, 1).normalize();
	scene.add(directionalLight);

	// floor
	var floorMaterial = new THREE.MeshBasicMaterial( { color: 0x444444, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -1.1;
	floor.rotation.x = Math.PI / 2;
	scene.add(floor);

	// sky
	var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xaaccff, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
	scene.add(skyBox);

	// cube
	var cposition = new THREE.Vector3(-15, 0, 0);
	var geometry = new THREE.CubeGeometry(1,2,8);
	var material = new THREE.MeshLambertMaterial({color: 0x000088, opacity: 0.5}); 
	cube = new THREE.Mesh(geometry, material); 
	cube.position = cposition;
	scene.add(cube);
	THREE.Collisions.colliders.push(THREE.CollisionUtils.MeshOBB(cube));
	
	var cposition = new THREE.Vector3(15, 0, 0);
	var geometry = new THREE.CubeGeometry(1,2,8);
	var material = new THREE.MeshLambertMaterial({color: 0x000088, opacity: 0.5}); 
	cube = new THREE.Mesh(geometry, material); 
	cube.position = cposition;
	scene.add(cube);
	THREE.Collisions.colliders.push(THREE.CollisionUtils.MeshOBB(cube));
	
	// sphere
	var rad = 1.0;
	var sposition = new THREE.Vector3(0, 0, 0);
	var geometry = new THREE.SphereGeometry(rad, 50, 50);
	var material = new THREE.MeshLambertMaterial({color: 0x008800}); 
	sphere = new THREE.Mesh(geometry, material); 
	sphere.position = sposition;
	scene.add(sphere);
	var sc = new THREE.SphereCollider(sposition, rad);
	sc.mesh = sphere;
	THREE.Collisions.colliders.push(sc);

	// stats - fps
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	container.appendChild(stats.domElement);

	// events
	document.addEventListener("keydown", function(event){
		//console.log(event.keyCode);
		if(event.keyCode == '37'){ //esquerda
			cube.position.x -= 1;
		}else if(event.keyCode == '38'){ //cima
			cube.position.z -= 1;
		}else if(event.keyCode == '39'){ //direita
			cube.position.x += 1;
		}else if(event.keyCode == '40'){ //baixo
			cube.position.z += 1;
		}else if(event.keyCode == '33'){ //page up
			cube.rotation.y += .1;
		}else if(event.keyCode == '34'){ //page down
			cube.rotation.y -= .1;
		}

	}, false);
	renderer.domElement.addEventListener('mousemove', function(event){

	});
	renderer.domElement.addEventListener('mousedown', function(event){
		//rotation();
		update();

	});
	renderer.domElement.addEventListener('mouseup', function(event){

	});

}

function animate() {
	requestAnimationFrame(animate);
	renderer.render(scene, camera);
	controls.update();
	stats.update();
	//update();
}

function update(){

	var ray = new THREE.Ray( sphere.position, new THREE.Vector3( 0, 0, 1 ) );
	var c = THREE.Collisions.rayCastNearest( ray );
	if(c != null){	
		console.log(c.distance);
	}
	
	if(direction == 1){
		sphere.position.x -= 0.5;
		if(c != null){
			direction = 0;
		}
	}else if(direction == 0){
		sphere.position.x += 0.5;
		if(c != null){
		//	direction = 1;
		}
	}

	/*var vector = new THREE.Vector3( 0, 0, 0 );
	var ray = new THREE.Ray( cube.position, vector.sub( cube.position ).normalize() );
	var cs = THREE.Collisions.rayCastAll( ray );
	//console.log(cs);
	if ( cs.length > 0 ) {
		console.log(cs.length + " colisao ");
		for ( var i = 0; i < cs.length; i ++ ) {
			console.log(cs[i].mesh);
			//console.log(cs[i].mesh.id);
			cs[ i ].mesh.material.color.setHex( 0xff0000 );
		}
	} else {
		console.log("sem colisao");
	}*/

}

function rotation(){
	cube.rotation.y += .05;

	renderer.render(scene, camera);
	requestAnimationFrame(rotation);
	stats.update();
}

window.onload = function(){
	init();
	animate();
}

/*
	var geometry = new THREE.SphereGeometry(1.2, 50, 50); 
	var material = new THREE.MeshLambertMaterial({color: 0x008800}); 
	sphere = new THREE.Mesh(geometry, material); 
	sphere.position.x = -10;
	scene.add(sphere);

	var material = new THREE.LineBasicMaterial({color: 0xffffff, linewidth:2}); 
	var geometry = new THREE.Geometry();
	geometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) ); 
	geometry.vertices.push( new THREE.Vector3( 1, 0, 0 ) ); 
	//geometry.vertices.push( new THREE.Vector3( 1, 0, -1 ) );

//	var line = new THREE.Line( geometry, material );
//	line.position.z = -1;
//	scene.add(line); 
*/

</script> 
</head> 
<body>
<div id="container"></div>
</body> 
</html>
