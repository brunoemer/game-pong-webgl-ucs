<html> 
<head> 
<title></title> 
<style>
body { margin: 0px; padding: 0px; }
canvas { width: 100%; height: 100% }
</style> 
<script src="js/three.min.js"></script> 
<script src="js/OrbitControls.js"></script> 
<script src="js/Detector.js"></script> 
<script src="js/CollisionUtils.js"></script>
<script src="js/Collisions.js"></script>
<script src="js/libs/stats.min.js"></script>
<script>
var scene, camera, renderer, container;
var cube, cube2, spheres = [];
var key = [];
var controls;
var stats;

var cube_width_z = 100;
var limit_x = 280;
var limit_z = 200;
var speed = 5, speed_cube = 5;
var direction_x = []; //0 left, 1 right
var direction_z = []; //0 top, 1 down

function init(){
	// scene
	scene = new THREE.Scene();

	// render
	var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
	container = document.getElementById('container');
	if ( Detector.webgl ){
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	}else{
		renderer = new THREE.CanvasRenderer(); 
	}
	renderer.setSize(WIDTH, HEIGHT);
	container.appendChild(renderer.domElement);

	// camera
	camera = new THREE.PerspectiveCamera(30, WIDTH / HEIGHT, 0.1, 20000);
	camera.position.set(0,550,550);
	scene.add(camera);
	camera.lookAt(scene.position);

	// controls
	controls = new THREE.OrbitControls(camera, renderer.domElement);
	controls.noKeys = true;

	// light
	var ambientLight = new THREE.AmbientLight(0x222222);
	scene.add(ambientLight);
	var directionalLight = new THREE.DirectionalLight(0xffffff);
	directionalLight.position.set(1, 1, 1).normalize();
	scene.add(directionalLight);

	// floor
	var floorMaterial = new THREE.MeshBasicMaterial( { color: 0x444444, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneGeometry(limit_x*2, limit_z*2, 1, 1);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -8;
	floor.rotation.x = Math.PI / 2;
	scene.add(floor);

	// sky
	var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xaaccff, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
	scene.add(skyBox);

	// cubes
	var cposition = new THREE.Vector3(230, 3, 0);
	var geometry = new THREE.CubeGeometry(10,20,cube_width_z);
	var material = new THREE.MeshLambertMaterial({color: 0x000088, opacity: 0.5}); 
	cube = new THREE.Mesh(geometry, material); 
	cube.position = cposition;
	scene.add(cube);
	THREE.Collisions.colliders.push(THREE.CollisionUtils.MeshOBB(cube));
	
	var cposition = new THREE.Vector3(-230, 3, 0);
	var geometry = new THREE.CubeGeometry(10,20,cube_width_z);
	var material = new THREE.MeshLambertMaterial({color: 0x000088, opacity: 0.5}); 
	cube2 = new THREE.Mesh(geometry, material); 
	cube2.position = cposition;
	scene.add(cube2);
	THREE.Collisions.colliders.push(THREE.CollisionUtils.MeshOBB(cube2));
	
	// sphere
	addSphere();

	// stats - fps
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	container.appendChild(stats.domElement);

	// events
	document.body.onkeydown = document.body.onkeyup = function(e){
		var e = e || event;
		key[e.keyCode] = e.type == 'keydown';
	};
	/*document.addEventListener("keydown", function(event){
		if(event.keyCode == '38'){ //cima
			cube.position.z -= speed_cube;
		}else if(event.keyCode == '40'){ //baixo
			cube.position.z += speed_cube;
		}
		if(event.keyCode == '33'){ //page up
			cube.rotation.y += .1;
		}
		if(event.keyCode == '34'){ //page down
			cube.rotation.y -= .1;
		}
		if(event.keyCode == '87'){ //w cima
			cube2.position.z -= speed_cube;
		}else if(event.keyCode == '83'){ //s baixo
			cube2.position.z += speed_cube;
		}

	}, false);
	renderer.domElement.addEventListener('mousemove', function(event){

	});
	renderer.domElement.addEventListener('mousedown', function(event){
		//rotation();
		//update();
	});*/
	renderer.domElement.addEventListener('mouseup', function(event){
		addSphere();
	});

}

function addSphere(){
	var rad = 7;
	var sposition = new THREE.Vector3(0, 0, 0);
	var geometry = new THREE.SphereGeometry(rad, 30, 30);
	var material = new THREE.MeshLambertMaterial({color: 0x000088}); 
	var sphere = new THREE.Mesh(geometry, material); 
	sphere.position = sposition;
	scene.add(sphere);
	var sc = new THREE.SphereCollider(sposition, rad);
	sc.mesh = sphere;
	THREE.Collisions.colliders.push(sc);
	spheres.push(sphere);
}

function animate() {
    //setTimeout( function() { //fps
	requestAnimationFrame(animate);
	update();
	controls.update();
	stats.update();
	renderer.render(scene, camera);
    //}, 1000 / 20 );
}

function update(){
	// events keys
	//console.log("up="+key[38]+"; down="+key[40]+"; wup="+key[87]+"; sdown="+key[83]+";");
	if(key[38]){ //cima
		if(cube.position.z-(cube_width_z/2) > -limit_z){
			cube.position.z -= speed_cube;
		}
	}else if(key[40]){ //baixo
		if(cube.position.z+(cube_width_z/2) < limit_z){
			cube.position.z += speed_cube;
		}
	}
	//if(key[33]){ //page up
	//	cube.rotation.y += .1;
	//}
	//if(key[34]){ //page down
	//	cube.rotation.y -= .1;
	//}
	if(key[87]){ //w cima
		if(cube2.position.z-(cube_width_z/2) > -limit_z){
			cube2.position.z -= speed_cube;
		}
	}else if(key[83]){ //s baixo
		if(cube2.position.z+(cube_width_z/2) < limit_z){
			cube2.position.z += speed_cube;
		}
	}
	
	// sphere move
	var i;
	for(i in spheres){
		if(direction_x[i] == 1){
			spheres[i].position.x += speed;
		}else if(direction_x[i] != 1){
			spheres[i].position.x -= speed;
		}
		if(direction_z[i] == 1){
			spheres[i].position.z += speed;
		}else if(direction_z[i] != 1){
			spheres[i].position.z -= speed;
		}

		if(spheres[i].position.x >= limit_x || spheres[i].position.x <= -limit_x){
			direction_x[i] = direction_x[i] != 1?1:0;
			//delete spheres[i];
			//delete direction_x[i];
			//delete direction_z[i];
		}
		if(spheres[i].position.z >= limit_z || spheres[i].position.z <= -limit_z){
			direction_z[i] = direction_z[i] != 1?1:0;
		}

		// colisao
		var ray = new THREE.Ray( spheres[i].position, new THREE.Vector3( 0, 0, 1 ) );
		var c = THREE.Collisions.rayCastNearest( ray );

		var color = "0x"+((1<<24)*Math.random()|0).toString(16);
		if(c != null && c.distance == -1){
			direction_x[i] = direction_x[i] != 1?1:0;
			c.mesh.material.color.setHex(color);
		}
	}

	/*var vector = new THREE.Vector3( 0, 0, 0 );
	var ray = new THREE.Ray( cube.position, vector.sub( cube.position ).normalize() );
	var cs = THREE.Collisions.rayCastAll( ray );
	//console.log(cs);
	if ( cs.length > 0 ) {
		console.log(cs.length + " colisao ");
		for ( var i = 0; i < cs.length; i ++ ) {
			console.log(cs[i].mesh);
			//console.log(cs[i].mesh.id);
			cs[ i ].mesh.material.color.setHex( 0xff0000 );
		}
	} else {
		console.log("sem colisao");
	}*/

}

window.onload = function(){
	init();
	animate();
}

/*
	var geometry = new THREE.SphereGeometry(1.2, 50, 50); 
	var material = new THREE.MeshLambertMaterial({color: 0x008800}); 
	sphere = new THREE.Mesh(geometry, material); 
	sphere.position.x = -10;
	scene.add(sphere);

	var material = new THREE.LineBasicMaterial({color: 0xffffff, linewidth:2}); 
	var geometry = new THREE.Geometry();
	geometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) ); 
	geometry.vertices.push( new THREE.Vector3( 1, 0, 0 ) ); 
	//geometry.vertices.push( new THREE.Vector3( 1, 0, -1 ) );

//	var line = new THREE.Line( geometry, material );
//	line.position.z = -1;
//	scene.add(line); 
*/

</script> 
</head> 
<body>
<div id="container"></div>
</body> 
</html>
